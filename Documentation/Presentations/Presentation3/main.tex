\documentclass[10pt]{beamer}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{mathtools}
\usetheme{CambridgeUS}
\usecolortheme{dolphin}
\usepackage{listings}
\usepackage{pdfpages}
\usepackage{listings}
\usepackage{venndiagram}


% Custom colors
\definecolor{myNewColorA}{RGB}{118,193,188}
\definecolor{myNewColorB}{RGB}{106,172,150}
\definecolor{myNewColorC}{RGB}{94,150,218}
\setbeamercolor*{palette primary}{bg=myNewColorC}
\setbeamercolor*{palette secondary}{bg=myNewColorB, fg=white}
\setbeamercolor*{palette tertiary}{bg=myNewColorA, fg=white}
\setbeamercolor*{titlelike}{fg=myNewColorA}
\setbeamercolor*{title}{bg=myNewColorA, fg=white}
\setbeamercolor*{item}{fg=myNewColorA}
\setbeamercolor*{caption name}{fg=myNewColorA}
\usefonttheme{professionalfonts}
% Set up hyperref once and configure colors
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    linktocpage=true
}

\titlegraphic{\includegraphics[height=1.5cm]{../CommonFigures/Universidad_Panamericana-logo.jpg}}

\setbeamerfont{title}{size=\large}
\setbeamerfont{subtitle}{size=\small}
\setbeamerfont{author}{size=\small}
\setbeamerfont{date}{size=\small}
\setbeamerfont{institute}{size=\small}
\title[Universidad Panamericana]{}
\subtitle{Professional Workflow}
\author[]{Name}
\institute[ltonix@up.edu.mx]{Universidad Panamericana}
\date[Presentation \today]{Presentation \today}

\AtBeginSection[]{
  \begin{frame}
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\insertsectionhead\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}

\setbeamercolor{block title}{bg=myNewColorA, fg=black} % Background and foreground colors for the block title
\setbeamercolor{block body}{bg=myNewColorC, fg=black} % Background and foreground colors for the block body

% Setup listings
\lstset{
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue},
  commentstyle=\color{green},
  stringstyle=\color{red},
  backgroundcolor=\color{gray!10},
  frame=single,
  language=C++,
  breaklines=true,
  showspaces=false,
  showstringspaces=false
}


\begin{document}

\frame{\titlepage}
\begin{frame}
\frametitle{Contents}
\tableofcontents
\end{frame}

\section{Why good practices?}
\begin{frame} {Why good practices?}
    \begin{itemize}
      \item \textbf{1. Maintainability}
      \begin{itemize}
        \item This is crucial for long-term projects where multiple developers might be working on the same codebase over time.
      \end{itemize}
      \item \textbf{2. Readability}
      \begin{itemize}
        \item Clear and consistent coding standards make it easier for developers to read and understand each other's code.
      \end{itemize}
      \item \textbf{3. Reusability}
      \begin{itemize}
        \item This means that code can be reused in different parts of a project or even in different projects, saving time and effort.
      \end{itemize}
      \item \textbf{4. Bug Reduction}
      \begin{itemize}
        \item Identifying and fixing bugs early in the development process.
      \end{itemize}
      \item \textbf{5. Performance}
      \begin{itemize}
        \item This is particularly important in applications where performance is critical, such as real-time systems or high-traffic web services.
      \end{itemize}
    \end{itemize}
  
\end{frame}

\begin{frame}{Why Good Practices?}
  \begin{itemize}
    \item \textbf{6. Scalability}
    \begin{itemize}
      \item Be easily extended with new features wiYout significant rework.
    \end{itemize}
    \item \textbf{7. Security}
    \begin{itemize}
      \item Secure data handling are crucial in preventing security breaches.
    \end{itemize}
    \item \textbf{8. Documentation}
    \begin{itemize}
      \item For future maintenance, debugging, and onboarding new developers.
    \end{itemize}
    \item \textbf{9. Consistency}
    \begin{itemize}
      \item It allows developers to switch between different parts of the codebase wiYout needing to adjust to different coding styles.
    \end{itemize}
    \item \textbf{10. Professionalism}
    \begin{itemize}
      \item It can enhance the reputation of a development team or company and build trust with clients and stakeholders.
    \end{itemize}
  \end{itemize}
\end{frame}


\begin{frame}{10 commandments}
  \begin{enumerate}
    \item \textbf{You shall prioritize Maintainability}
    \item \textbf{You shall value Readability}
    \item \textbf{You shall strive for Reusability}
    \item \textbf{You shall reduce Bugs early}
    \item \textbf{You shall optimize Performance}
    \item \textbf{You shall ensure Scalability}
    \item \textbf{You shall secure thy code}
    \item \textbf{You shall document thoroughly}
    \item \textbf{You shall maintain Consistency}
    \item \textbf{You shall uphold Professionalism}
  \end{enumerate}
\end{frame}



\section{Use other programming languages}
\begin{frame} {You shouldn't be opposed to learning programming languages.}
  \begin{itemize}
    \item Latex : Documentation
    \item Java: PlantUML
    \item JSON: For automatization stuff
    \item Python: Unit Testing
    \item C: Pretty basic programming
    \item Cpp: Robust programming
    \item C\#: Windows App
  \end{itemize}

\end{frame}

\includepdf{figures/SoftwareProductCycle.pdf}

\section{Requirements}
\begin{frame} {Requirements}
  DOORS is a requirements management tool used by organizations to manage project requirements throughout the development lifecycle. It helps in capturing, analyzing, tracing, and maintaining changes to information to ensure a project's compliance with its initial requirements. This tool is particularly useful for managing complex projects, providing traceability, and improving collaboration and verification efforts.
  \href{https://doorstop.readthedocs.io/en/latest/}{Requirements}
\end{frame}


\section{SDD}
\begin{frame} {Software Detailed Document (SDD)}
  The SDD serves as a guide for developers during the build phase and aids in maintaining consistency and understanding of the system's design principles and functionalities.
  \href{https://docs.google.com/document/d/1unF8FmWHeOJKlPy6cR2QpmrcaOKSOiiO/edit?usp=sharing&ouid=109808472061203912811&rtpof=true&sd=true}{SDD}
\end{frame}

\section{UML}
\begin{frame} {Unified Modeling Language with PlantUML (UML)}
  UML diagrams serve as excellent documentation tools that are useful throughout the system's lifecycle. \
  They help new team members understand the system quickly and can also be valuable for maintenance and future upgrades.
  \href{https://plantuml.com/}{PlantUML}
\end{frame}

\begin{frame} {Abstract class as interface}
  \begin{itemize}
    \item \textbf{Abstract Class in C++:} In C++, an abstract class is defined by declaring at least one pure virtual function, which is a function with no implementation (denoted by `= 0`). This makes the class abstract, meaning it cannot be instantiated directly.
    
    \item \textbf{Interface Concept:} In C++, abstract classes are often used to define interfaces. An interface in this context is a class that provides a set of virtual methods that derived classes must implement. This allows you to enforce a consistent API across different subclasses.
    
    \item \textbf{Pure Virtual Functions:} A pure virtual function in C++ is declared like this: `virtual void functionName() = 0;`. Any class that inherits from an abstract class must provide an implementation for all pure virtual functions, or it will also be considered abstract.
    
    \item \textbf{Usage in C++:} Abstract classes are used in C++ to create a common interface for a group of related classes. For example, an abstract class `Shape` could define a pure virtual function `draw()`, forcing all derived classes like `Circle`, `Square`, or `Triangle` to implement their own version of `draw()`.

  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Abstract Class as Interface in C++}
  \begin{itemize}
      \item \textbf{Example:}
  \end{itemize}
  \begin{lstlisting}
    // Abstract base class
    class Shape {
    public:
      virtual void draw() = 0; // Pure virtual function
    };

    // Derived class
    class Circle : public Shape {
    public:
    void draw() override {
      // Implementation for drawing a circle
      }
    };
  \end{lstlisting}
\end{frame}


\begin{frame}{Enums to Avoid Magic Numbers}
  \begin{itemize}
      \item \textbf{Magic Numbers:} Magic numbers are hard-coded values in your code that have no clear meaning or context. They make the code difficult to understand and maintain, as the purpose of these numbers is not immediately clear.
      
      \item \textbf{Problem with Magic Numbers:} 
      \begin{itemize}
          \item Reduce code readability.
          \item Make the code error-prone, as changing a value requires finding and updating every instance.
          \item Lack of context or explanation for what the number represents.
      \end{itemize}
      
      \item \textbf{Solution: Using Enums:} 
      \begin{itemize}
          \item Enums (enumerations) provide a way to define a set of named integer constants.
          \item They improve code readability and maintainability by replacing magic numbers with descriptive names.
          \item Enums also allow for easier updates since you only need to change the value in one place.
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Example: Using Enums in C++}
  \begin{lstlisting}[language=C++]
// Avoiding magic numbers using enum
enum Direction {
  North = 0,
  East = 1,
  South = 2,
  West = 3
};

void move(Direction dir) {
  if (dir == North) {
      // Move north
  } else if (dir == East) {
      // Move east
  }
  // and so on...
}
  \end{lstlisting}
\end{frame}

\begin{frame}
  \begin{itemize}
    \item \textbf{Benefits:}
    \begin{itemize}
        \item \textbf{Clarity:} The code becomes self-documenting, making it easier to understand the purpose of the values.
        \item \textbf{Maintenance:} Changing the underlying value of an enum only requires updating the enum definition, not every occurrence in the code.
        \item \textbf{Safety:} Enums provide type safety, reducing the likelihood of errors from using incorrect values.
    \end{itemize}
\end{itemize}
\end{frame}



\begin{frame}{SOLID Principles}
  \begin{itemize}
      \item \textbf{SOLID:} A set of five design principles that promote better software architecture in object-oriented programming.
      
      \item \textbf{S - Single Responsibility Principle (SRP):}
      \begin{itemize}
          \item A class should have only one reason to change.
      \end{itemize}

      \item \textbf{O - Open/Closed Principle (OCP):}
      \begin{itemize}
          \item Classes should be open for extension, but closed for modification.
      \end{itemize}

      \item \textbf{L - Liskov Substitution Principle (LSP):}
      \begin{itemize}
          \item Subclasses should be replaceable for their base classes without altering the program's behavior.
      \end{itemize}

      \item \textbf{I - Interface Segregation Principle (ISP):}
      \begin{itemize}
          \item Clients should not be forced to depend on interfaces they do not use.
      \end{itemize}

      \item \textbf{D - Dependency Inversion Principle (DIP):}
      \begin{itemize}
          \item Depend on abstractions, not on concrete implementations.
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Course Activity: Practicing Critical Software Components}
  During this course, you will engage in hands-on practice to solidify your understanding of key software design principles and components. The activities include:
  \begin{itemize}
      \item \textbf{Design an Abstract Class in PlantUML:}
      \begin{itemize}
          \item Create a PlantUML diagram for an abstract class that encapsulates common functionalities across all controllers.
      \end{itemize}

      \item \textbf{Develop Base Classes:}
      \begin{itemize}
          \item Write two base classes, which can be either realistic or mock implementations, to practice inheritance and abstraction.
      \end{itemize}

      \item \textbf{Define Enums:}
      \begin{itemize}
          \item Create enumerations for potential errors, sensor types, and processing steps, ensuring clarity and avoiding magic numbers.
      \end{itemize}

      \item \textbf{Present Your Design:}
      \begin{itemize}
          \item Showcase your PlantUML design on the projector, explaining your design decisions and how they align with SOLID principles.
      \end{itemize}

      \item \textbf{Justify with SOLID:}
      \begin{itemize}
          \item Ensure that your design choices adhere to SOLID principles, providing justification for each decision based on these foundational guidelines.
      \end{itemize}
  \end{itemize}
\end{frame}

\section{Planning}
\begin{frame} {Planning}
  In Scrum, a popular agile framework used in software development, two fundamental concepts are "story" and "sprint." Here's a brief explanation of each:
  \begin{itemize}
    \item A user story is a brief description of a feature from the user's perspective, aimed at ensuring the team delivers value based on user needs. It’s formatted as: "As a [user], I want [goal] so that [reason]."
    \item A sprint is a time-boxed period (usually 1-4 weeks) where a team completes a set work chunk to produce a shippable product increment, incorporating planning, development, and review.
  \end{itemize}

  \href{Taiga.io}{Taiga IO}
\end{frame}

\section{Develop}

\begin{frame} {Coding Standard}
  \href{https://google.github.io/styleguide/cppguide.html}{Google coding standard}
  \begin{itemize}
    \item Prevent using magic numbers instead use enums, or constantands or finally defines.
  \end{itemize}
\end{frame}

\begin{frame} {Linter vs Compiler}
  \begin{itemize}
    \item Clang tidy is a linter is a tool that analyzes source code to flag programming errors, bugs, stylistic errors, and suspicious constructs.
    \item A compiler translates code written in a high-level programming language into a lower-level language, typically machine code that a computer's processor can execute directly.
  \end{itemize}
\end{frame}

\begin{frame} {ESP IDF}
    \begin{itemize}
      \item  ESP-IDF is designed to make it straightforward to program ESP32 functionalities in C or C++, 
      \item Offers advanced features, real-time capabilities, and robust system-level functions for efficient management of tasks and power.
    \end{itemize}
\end{frame}

\begin{frame} {More Visual studio code extensions}
  \begin{itemize}
    \item vscode-Icons
    \item Bracket pair coloriser
    \item Bookmarks
    \item Cs 128 Clang-tidy
    \item Enumerator
    \item GitLens
    \item Meld diff
    \item Plant UML
    \item Todo tree
    \item Live Share
  \end{itemize}
  
\end{frame}

\section{TPD}
\begin{frame} {Test plan document (TPD)}
  A Test Plan Document (TPD) outlines the strategy, resources, scope, and timeline for testing activities within a software project. It serves as a blueprint that guides the testing process, detailing what needs to be tested, how the testing will be conducted, who will perform the tests, and the expected outcomes
  \href{https://docs.google.com/document/d/1lC8ZuRmzqU7DRiWEhfb8iwjCS3WTwKQk/edit?usp=sharing&ouid=109808472061203912811&rtpof=true&sd=true}{TPD}
\end{frame}

\section{Testing}
\begin{frame} {Black box vs Whitebox testing}
\begin{itemize}
  \item Black Box Testing: Tests the functionality of software without knowledge of its internal workings, focusing on input and output.
  \item White Box Testing: Examines the internal structure and workings of software, requiring knowledge of the code to ensure through testing of internal operations.
\end{itemize}
\end{frame}

\begin{frame} {Embbeded Unit Testing Framework}
  \begin{itemize} 
    \item Unit Testing is a way to check your code behaves systematically.
      \item \url{https://github.com/espressif/pytest-embedded}
      \item Example can be seen in \texttt{FreeRTOSCourse/Projects/dac\_cosine\_wave/pytest\_dac\_cosine\_wave.py}
  \end{itemize}
\end{frame}

\section{Git}
\begin{frame}{Git}
  \href{run:git basics.pptx}{Open Git Presentation}
\end{frame}

\end{document}